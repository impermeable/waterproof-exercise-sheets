# Metric spaces<hint title="üì¶ Import libraries (click to open/close)">
```coq
From Stdlib Require Import Reals.Reals.
From Stdlib Require Import Sets.Image.
Require Import Waterproof.Tactics.
Require Import Waterproof.Notations.Common.
Require Import Waterproof.Notations.Reals.
Require Import Waterproof.Notations.Sets.
Require Import Waterproof.Chains.
Require Import Waterproof.Automation.

From Stdlib Require Import String.

Require Import Waterproof.Libs.Analysis.MetricSpaces.

Waterproof Enable Automation RealsAndIntegers.

Set Default Goal Selector "!".

Notation "'max(' x , y )" := (Rmax x y)
  (format "'max(' x ,  y ')'").
Notation "'min(' x , y )" := (Rmin x y)
  (format "'min(' x ,  y ')'").

Inductive answer : Type :=
| Yes : answer.

Set Bullet Behavior "Waterproof Relaxed Subproofs".
```
</hint>#### **Before we start, some remarks regarding syntax.**

The formulation of the proof steps available in Waterproof is quite strict. You can always consult the tutorial to revisit these formulations.
You can also click the water drop on the left and click on the "Tactics" button and a list with possible tactics will show up.

## Exercise 3.7.1
```coq
Section Exercise_3_7_1.

Variable (Y : Metric_Space) (X : Set) (f : X ‚Üí Y).
Parameter f_injective : injective _ _ f.
Notation "'injectivity' 'of' 'f'" := f_injective.

Notation "'dist_Y' '(' x , z )" := (dist Y x z) (format "'dist_Y' '(' x ,  z ')'").

Variable d : X -> X -> ‚Ñù.
Parameter definition_d :
  ‚àÄ x ‚àà X, ‚àÄ z ‚àà X, d(x, z) = dist_Y(f(x), f(z)).
```
<hint title="üîß Technical details (click to open/close)">
```coq
Notation "'the' 'definition' 'of' 'd'" := "definition_d"%string.

Create HintDb definition_d.
Hint Extern 0 => rewrite definition_d : definition_d.
Hint Extern 1 => rewrite <- definition_d : definition_d.

Definition dist_positive_Y :
  ‚àÄ a ‚àà Y, ‚àÄ b ‚àà Y, dist_Y(a, b) ‚â• 0 := dist_positive Y.
Notation "'positivity' 'of' 'dist_Y'" := dist_positive_Y.

Definition dist_non_degenerate_Y :
  ‚àÄ a ‚àà Y, ‚àÄ b ‚àà Y, dist_Y(a, b) = 0 ‚áí a = b := dist_non_degenerate Y.
Notation "'non-degeneracy' 'of' 'dist_Y'" := dist_non_degenerate_Y.

Definition dist_symmetric_Y :
  ‚àÄ a ‚àà Y, ‚àÄ b ‚àà Y, dist_Y(a, b) = dist_Y(b, a) := dist_symmetric Y.
Notation "'symmetry' 'of' 'dist_Y'" := dist_symmetric_Y.

Definition dist_triangle_inequality_Y :
  ‚àÄ a ‚àà Y, ‚àÄ b ‚àà Y, ‚àÄ c ‚àà Y,
    dist_Y(a, c) ‚â§ dist_Y(a, b) + dist_Y(b, c) :=
  dist_triangle_inequality Y.

Notation "'the' 'triangle' 'inequality' 'for' 'dist_Y'" :=
  dist_triangle_inequality_Y.

Definition dist_reflexive_Y :
  ‚àÄ a ‚àà Y, dist_Y(a, a) = 0 := dist_reflexive Y.
Notation "'reflexivity' 'of' 'dist_Y'" := dist_reflexive_Y.
```
</hint>
The above basically says: Let $(Y, \mathsf{dist}_Y)$ be a metric space, let $X$ is a set, and assume $f : X \rightarrow Y$ is injective.

Let the function $d : X \times X \rightarrow \mathbb{R}$ satisfy that for all $x, z \in X$,
$$
d(x, z) := \mathsf{dist}_Y(f(x), f(z)).
$$
In this exercise we would like to check that $d$ is a distance on $X$, by checking the five properties of a distance. Because $\text{dist}_Y$ is a distance, it satisfies those five properties which define the concept of *distance*:
```coq
Check positivity of dist_Y.
Check non-degeneracy of dist_Y.
Check symmetry of dist_Y.
Check the triangle inequality for dist_Y.
Check reflexivity of dist_Y.
```
You can use any of these facts in a construction like
```
By positivity of dist_Y it holds that ...
```
If you want to use the injectivity of `f`, you can refer to it by
```
injectivity of f
```
If you want to use the definition of `d`, you can refer to it by
```
the definition of d
```<hint title="üí° Hint (click to open/close)">You can even use multiple reasons in one line, by writing

```
By reason 1 and reason 2 it holds that ...
```
or
```
By reason 1, reason 2, ..., reason n-1 and reason n it holds that ...
```

Note that the syntax is quite strict, and you cannot just use this for any reasons, but you can use this for the reasons mentioned above.

Good luck!</hint><hint title="üí° Hint (click to open/close)">Recall from the `tutorial` that to write a chain of (in)equalities you can use the following syntax

`
We conclude that
  (&  3 < 4 = 2 + 2).
`</hint>
```coq
Lemma d_positive : ‚àÄ x ‚àà X, ‚àÄ y ‚àà X, d(x, y) ‚â• 0.
Proof.
```
<input-area>
```coq

```
</input-area>
```coq
Qed.
```

```coq
Lemma d_non_degenerate : ‚àÄ x ‚àà X, ‚àÄ y ‚àà X, (d(x, y) = 0) ‚áí (x = y).
Proof.
```
<input-area>
```coq

```
</input-area>
```coq
Qed.
```

```coq
Lemma d_symmetric : ‚àÄ x ‚àà X, ‚àÄ y ‚àà X, d(x, y) = d(y, x).
Proof.
```
<input-area>
```coq

```
</input-area>
```coq
Qed.
```

```coq
Lemma d_triangle_inequality : ‚àÄ x ‚àà X, ‚àÄ y ‚àà X, ‚àÄ z ‚àà X,
  d(x, z) ‚â§ d(x, y) + d(y, z).
Proof.
```
<input-area>
```coq

```
</input-area>
```coq
Qed.
```

```coq
Lemma d_reflexive : ‚àÄ x ‚àà X, d(x, x) = 0.
Proof.
```
<input-area>
```coq

```
</input-area>
```coq
Qed.
```

```coq
End Exercise_3_7_1.
```
## Exercise 3.7.3
```coq
Module Exercise_3_7_3.
```
Consider the function $d : \mathbb{R} \times \mathbb{R} \to \mathbb{R}$ defined by
$$
  d(a, b) =
	\begin{cases}
		0, &\text{if } a = b,\\
		3, &\text{if } a \neq b.
	\end{cases}
$$
Show that $d$ is a distance function on $\mathbb{R}\,$.<hint title="üí° Hint (click to open/close)">In the following lemmas, you will notice that you have to distinguish cases.
In particular, it might be useful to distinguish on the cases $a = b$ and $a \neq b$.

In Waterproof, you can do that by using the following:

```Either (```*case 1*```) or (```*case 2*```).```</hint><hint title="üí° Hint (click to open/close)">**Remember:** to add the symbol `‚â†`, type `\not-equal` and press **Enter**.</hint>
```coq
Notation "'d(' a , b )" := (d_discrete_R a b) (format "'d(' a ,  b ')'").
```

```coq
Lemma d_positive : ‚àÄ a ‚àà ‚Ñù, ‚àÄ b ‚àà ‚Ñù, d(a, b) ‚â• 0.
Proof.
```
<input-area>
```coq

```
</input-area>
```coq
Qed.
```
<hint title="üîß Technical details (click to open/close)">
```coq
Notation "'positivity' 'of' 'd'" := d_positive.
```
</hint>
```coq
Lemma d_non_degenerate :
  ‚àÄ a ‚àà ‚Ñù, ‚àÄ b ‚àà ‚Ñù, (d(a, b) = 0) ‚áí (a = b).
Proof.
```
<input-area>
```coq

```
</input-area>
```coq
Qed.
```
<hint title="üîß Technical details (click to open/close)">
```coq
Notation "'non-degeneracy' 'of' 'd'" := d_non_degenerate.
```
</hint>
```coq
Lemma d_symmetric : ‚àÄ a ‚àà ‚Ñù, ‚àÄ b ‚àà ‚Ñù, d(a, b) = d(b, a).
Proof.
```
<input-area>
```coq

```
</input-area>
```coq
Qed.
```
<hint title="üîß Technical details (click to open/close)">
```coq
Notation "'symmetry' 'of' 'd'" := d_symmetric.
```
</hint>
<hint title="üí° Hint (click to open/close)">
If you know that $a = b$ and $b = c$, what do you know about the relation between $a$ and $c$?
What do you know for the case when $a \neq b$ and $b = c$ or when $a = b$ and $b \neq c$?
And for $a \neq b$ and $b \neq c$?</hint>
```coq
Lemma d_triangle_inequality :
  ‚àÄ a ‚àà ‚Ñù, ‚àÄ b ‚àà ‚Ñù, ‚àÄ c ‚àà ‚Ñù, d(a, c) ‚â§ d(a, b) + d(b, c).
Proof.
```
<input-area>
```coq

```
</input-area>
```coq
Qed.
```
<hint title="üîß Technical details (click to open/close)">
```coq
Notation "'the' 'triangle' 'inequality' 'for' 'd'" := d_triangle_inequality.
```
</hint>
```coq
Lemma d_reflexive : ‚àÄ a ‚àà ‚Ñù, d(a, a) = 0.
Proof.
```
<input-area>
```coq

```
</input-area>
```coq
Qed.
```
<hint title="üîß Technical details (click to open/close)">
```coq
Notation "'reflexivity' 'of' 'd'" := d_reflexive.
```
</hint>
```coq
End Exercise_3_7_3.
```
## Declaration of own work

Please declare that the work above is your own work, by writing `Yes.` as an answer on the line below. In particular, this means that the proofs above are typed by yourself, and that you could give an explanation of the proof when asked.
```coq
Definition own_work : answer. exact
```
<input-area>
```coq

```
</input-area>
```coq
Qed.
```
