# Point-set topology<hint title="üì¶ Import libraries (click to open/close)">
```coq
Set Default Goal Selector "!".

Require Import Stdlib.Logic.FunctionalExtensionality.
Require Import Stdlib.Reals.Reals.
Require Import Stdlib.Logic.ClassicalChoice.
Require Import Stdlib.Logic.PropExtensionality.
Require Import Waterproof.Tactics.
Require Import Waterproof.Notations.Common.
Require Import Waterproof.Notations.Reals.
Require Import Waterproof.Notations.Sets.
Require Import Waterproof.Chains.
Require Import Waterproof.Libs.Analysis.Sequences.
Require Import Waterproof.Libs.Analysis.OpenAndClosed.

Require Import Waterproof.Automation.

From Waterproof Require Import Negation.
From Waterproof Require Import ArchimedN.


Waterproof Enable Automation RealsAndIntegers.
Waterproof Enable Automation Intuition.

Open Scope R_scope.
Open Scope subset_scope.

Notation "'max(' x , y )" := (Rmax x y)
  (format "'max(' x ,  y ')'").
Notation "'min(' x , y )" := (Rmin x y)
  (format "'min(' x ,  y ')'").

Lemma seq_char (A : subset R) : 
  ((‚àÄ q ‚àà ‚Ñù, ‚àÄ z : ‚Ñï ‚Üí ‚Ñù,
    (‚àÄ n ‚àà ‚Ñï, z(n) ‚àà A) ‚áí
      z ‚ü∂ q ‚áí q ‚àà A)) ‚áî A is closed.
Proof.
split.
- Assume that (‚àÄ q ‚àà ‚Ñù, ‚àÄ z : ‚Ñï ‚Üí ‚Ñù, (‚àÄ n ‚àà ‚Ñï, z(n) ‚àà A) ‚áí z ‚ü∂ q ‚áí q ‚àà A) as (i).
  We need to show that ‚àÄ a ‚àà ‚Ñù\A, ‚àÉ r > 0, ‚àÄ x ‚àà B(a, r), x ‚àà ‚Ñù\A.
  Take a ‚àà ‚Ñù\A.
  We argue by contradiction.
  Assume that ¬¨ (‚àÉ r > 0, ‚àÄ x ‚àà B(a, r), x ‚àà ‚Ñù\A).
  It holds that ‚àÄ r > 0, ‚àÉ x ‚àà B(a, r), ¬¨ (x ‚àà ‚Ñù\A).
  We claim that ‚àÄ n : ‚Ñï, ‚àÉ x : ‚Ñù, x ‚àà B(a, Rinv (n+1)) ‚àß x ‚àà A as (iii).
  {
    Take n : ‚Ñï.
    It holds that (1 / (n+1)) > 0.
    It holds that ‚àÉ x1 ‚àà B(a, Rinv (n + 1)), ¬¨ (x1 ‚àà ‚Ñù \ A).
    Obtain such x1.
    Choose x := x1.
    We show both statements.
    - We conclude that x ‚àà B(a, Rinv (n+1)).
    - We conclude that x ‚àà A.    
  }
  We claim that ‚àÉ z : ‚Ñï ‚Üí ‚Ñù, ‚àÄ n : ‚Ñï, z(n) ‚àà B(a, Rinv (n+1)) ‚àß z(n) ‚àà A as (iv).
  {
    exact (@choice ‚Ñï ‚Ñù (fun n y => y ‚àà B(a, Rinv (n+1)) ‚àß y ‚àà A) iii).
  }
  Obtain such a z.
  We claim that z ‚ü∂ a.
  {
    intros Œµ v.
    By the Archimedean property it holds that ‚àÉ N2 ‚àà ‚Ñï, N2 > 1 / Œµ.
    Obtain such an N2.
    Choose N1 := N2.
    { Indeed, N1 ‚àà ‚Ñï. }
    We need to show that ‚àÄ n ‚â• N1, ÔΩúz(n) - aÔΩú < Œµ.
    Take n ‚â• N1.
    It holds that z(n) ‚àà B(a, Rinv (n+1)) ‚àß z(n) ‚àà A.
    It holds that z(n) ‚àà B(a, Rinv (n+1)).
    It holds that | z(n) - a | < Rinv (n + 1).
    It holds that n ‚â• N1.
    It holds that Rinv Œµ > 0.
    It holds that 1 / Œµ > 0.
    It holds that & n ‚â• N1 = N2 > 1 / Œµ = Rinv Œµ.
    It holds that n > 0.
    By Rinv_lt_contravar it holds that & Rinv (n+1) < Rinv n < Rinv (Rinv Œµ) = Œµ.
    We conclude that & R_dist (z(n), a) = | z(n) - a | < Œµ.
  }
  We claim that ‚àÄ n ‚àà ‚Ñï, z(n) ‚àà A.
  {
    Take n ‚àà ‚Ñï.
    It holds that z(n) ‚àà B(a, / (n + 1)) ‚àß z(n) ‚àà A.
    We conclude that z(n) ‚àà A.
  }
  Use q := a, z0 := z in (i).
  { Indeed, a ‚àà ‚Ñù. }
  It holds that (‚àÄ n ‚àà ‚Ñï, z(n) ‚àà A) ‚á® z ‚ü∂ a ‚á® a ‚àà A.
  It holds that a ‚àà A.
  Contradiction.
- Assume that A is closed as (i).
  Take q ‚àà ‚Ñù.
  Take z : ‚Ñï ‚Üí ‚Ñù.
  Assume that (‚àÄ n ‚àà ‚Ñï, z(n) ‚àà A).
  Assume that z ‚ü∂ q.
  It holds that ‚àÄ a ‚àà ‚Ñù\A, ‚àÉ r > 0, ‚àÄ x ‚àà B(a, r), x ‚àà ‚Ñù\A as (ii).
  We argue by contradiction.
  Assume that ¬¨ q ‚àà A.
  It holds that q ‚àà ‚Ñù\A.
  It holds that ‚àÉ r > 0, ‚àÄ x ‚àà B(q, r), x ‚àà ‚Ñù\A.
  Obtain such an r.
  It holds that ‚àÉ N1 ‚àà ‚Ñï, ‚àÄ n ‚â• N1, R_dist(z(n) , q) < r.
  Obtain such an N1.
  It holds that R_dist(z(N1), q) < r.
  It holds that |z(N1) - q| < r.
  It holds that z(N1) ‚àà A.
  It holds that z(N1) ‚àà B(q, r).
  It holds that z(N1) ‚àà ‚Ñù\A.
  Contradiction.
Qed.
  
Waterproof Register Expand "closed";
  for is_closed;
  as "Sequence characterization of closedness";
  by rewrite (fun A => propositional_extensionality _ _ (seq_char A)).
Hint Extern 1 => setoid_rewrite (fun A => propositional_extensionality _ _ (seq_char A)) : wp_core.

Lemma double_complement (A : subset ‚Ñù) : ‚Ñù \ (‚Ñù\A) = A.
Proof.
  apply functional_extensionality.
  intro x.
  apply propositional_extensionality.
  split.
  - Assume that x ‚àà ‚Ñù\(‚Ñù\A).
    It holds that ¬¨ x ‚àà ‚Ñù \ A.
    It suffices to show that x ‚àà A.
    We conclude that x ‚àà A.
  - Assume that x ‚àà A.
    We need to show that ¬¨ x ‚àà ‚Ñù \ A.
    We conclude that ¬¨ x ‚àà ‚Ñù \ A.
Qed.

Lemma alt_char_open (A : subset ‚Ñù) : ‚Ñù\A is closed ‚áî A is open.
Proof.
split.
- Assume that ‚Ñù\A is closed.
  It holds that (‚Ñù\(‚Ñù \ A) is open).
  By double_complement it holds that A = ‚Ñù\(‚Ñù \ A) as (i).
  It suffices to show that ‚Ñù\(‚Ñù \ A) is open.
  We conclude that ‚Ñù\(‚Ñù \ A) is open.
- Assume that A is open.
  We need to show that ‚Ñù\(‚Ñù \ A) is open.
  By double_complement it holds that ‚Ñù\(‚Ñù \ A) = A as (i).
  It suffices to show that A is open.
  We conclude that A is open.
Qed.

Waterproof Register Expand "open";
  for is_open;
  as "Alternative characterization open";
  by apply alt_char_open.

Hint Resolve alt_char_open | 2 : wp_core.
Hint Resolve <- alt_char_open : wp_core.

Waterproof Register Expand "closed";
  for is_closed;
  as "Sequence characterization of closedness";
  by apply seq_char.

Hint Resolve seq_char | 2 : wp_core.
Hint Resolve <- seq_char : wp_core.
Hint Extern 1 => ltac2:(solve_by_manipulating_negation (fun () => ())) : wp_reals.

Inductive answer : Type :=
| Yes : answer.

Set Bullet Behavior "Waterproof Relaxed Subproofs".
```
</hint>
In the proofs below, you can use the definition of open and closed sets, or you can use the sequence characterization of closedness. Both are available through the `Expand All.` command.

Recall that $x \in B(p, r)$ if and only if $|x - p| < r$.

If you use the sequence characterization of closedness, it will be very useful to use the sequences below. You can use without proof that for all $n \in \mathbb{N}$, $a_n \notin [0, 1)$ and $b_n \in [0, 1)$, and that $a$ converges to $0$ and $b$ converges to $1$.
```coq
Definition a (n : ‚Ñï) := - (1 / (n + 1)).
Definition b (n : ‚Ñï) := 1 - (1 / (n + 1)).
```
<hint title="üîß Technical details (click to open/close)">
```coq
Lemma a_converges_to_0 : a ‚ü∂ 0.
Proof.
By min_1_over_n_plus_1_to_0 we conclude that (converges_to a 0).
Qed.

Lemma b_converges_to_1 : b ‚ü∂ 1.
Proof.
It holds that 1 = 1 + 0.
It suffices to show that b ‚ü∂ (1 + 0).
It suffices to show that (fun n => (constant_sequence 1)(n) + a(n)) ‚ü∂ (1 + 0).
By lim_const_seq, a_converges_to_0 and convergence_plus we conclude that
  ((fun n => (constant_sequence 1)(n) + a(n)) ‚ü∂ (1 + 0)) as (i).
Qed.

Lemma a_neg (n : ‚Ñï) : a(n) < 0.
Proof.
It holds that (n + 1) > 0.
It holds that / (n + 1) > 0.
We conclude that & a(n) = - (1 / (n + 1)) = - / (n + 1) < 0.
Qed.

Lemma a_notin_interv (n : ‚Ñï) : a(n) ‚àà ‚Ñù\[0, 1).
Proof.
We need to show that ¬¨ a(n) ‚àà [0, 1).
It suffices to show that a(n) < 0.
By a_neg we conclude that a(n) < 0.
Qed.

Lemma b_in_interv (n : ‚Ñï) : b(n) ‚àà [0, 1).
Proof.
We need to show that 0 <= b(n) < 1.
It holds that n ‚â• 0.
It holds that (n + 1) ‚â• 1.
By Rinv_le_contravar it holds that
    & 1 / (n + 1) = / (n + 1) ‚â§ / 1 = 1.
It holds that / (n + 1) > 0.
We show both statements.
- We need to show that 0 ‚â§ 1 - (1/(n+1)).  
  We conclude that 0 ‚â§ 1 - (1/(n+1)).
- We need to show that 1 - (1/(n+1)) < 1.
  By a_neg it holds that - (1/(n+1)) < 0.
  We conclude that 1 - (1/(n+1)) < 1.  
Qed.

Hint Resolve a_converges_to_0 : wp_reals.
Hint Resolve b_converges_to_1 : wp_reals.
Hint Resolve a_neg : wp_reals.
Hint Resolve a_notin_interv : wp_reals.
Hint Resolve b_in_interv : wp_reals.
```
</hint>
## Exercise: prove that the interval $[0, 1)$ is not open
```coq
Lemma not_open : ¬¨ ([0,1) is _open_).
Proof.
```
<input-area>
```coq

```
</input-area>
```coq
Qed.
```

## Exercise: prove that the interval $[0, 1)$ is not closed.
```coq
Lemma not_closed : ¬¨ ([0,1) is _closed_).
Proof.
```
<input-area>
```coq

```
</input-area>
```coq
Qed.
```
## Declaration of own work

Please declare that the work above is your own work, by writing `Yes.` as an answer on the line below. In particular, this means that the proofs above are typed by yourself, and that you could give an explanation of the proof when asked.
```coq
Definition own_work : answer. exact
```
<input-area>
```coq

```
</input-area>
```coq
Qed.
```
